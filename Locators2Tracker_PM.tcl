set cut_paste_input [stack 0]
version 16.0 v4
push $cut_paste_input
NoOp {
name Locators2Tracker_PM
tile_color 0xffff00ff
selected true
xpos 292
ypos 27
addUserKnob {20 User l Locators2Tracker_PM}
addUserKnob {1 cam l "Camera Name"}
cam Camera2
addUserKnob {1 loc l "Locators Name"}
loc locator
addUserKnob {26 ""}
addUserKnob {26 _1 l "" +STARTLINE T "Select Locators\nPush Calculate"}
addUserKnob {22 cal l Calculate -STARTLINE T "import nuke\nfrom nukescripts import snap3d as sn\nimport math\nimport fnmatch\n\ndef cameraProjectionMatrix(cameraNode, frame, imageformat):\n    \"\"\"Modified code from nukescripts/Snap3D\"\"\"\n    # Matrix to transform points into camera-relative coords.\n    wm = nuke.math.Matrix4()\n    for i in range(16):\n        wm\[i] = cameraNode\['matrix'].getValueAt(frame, i)\n\n    wm.transpose()\n    camTransform = wm.inverse()\n\n    # Matrix to take the camera projection knobs into account\n    roll = float(cameraNode\['winroll'].getValueAt(frame, 0))\n    scale_x = float(cameraNode\['win_scale'].getValueAt(frame, 0))\n    scale_y = float(cameraNode\['win_scale'].getValueAt(frame, 1))\n    translate_x = float(cameraNode\['win_translate'].getValueAt(frame, 0))\n    translate_y = float(cameraNode\['win_translate'].getValueAt(frame, 1))\n    m = nuke.math.Matrix4()\n    m.makeIdentity()\n    m.rotateZ(math.radians(roll))\n    m.scale(1.0 / scale_x, 1.0 / scale_y, 1.0)\n    m.translate(-translate_x, -translate_y, 0.0)\n\n    # Projection matrix based on the focal length, aperture and clipping planes of the camera\n    focal_length = float(cameraNode\['focal'].getValueAt(frame))\n    h_aperture = float(cameraNode\['haperture'].getValueAt(frame))\n    near = float(cameraNode\['near'].getValueAt(frame))\n    far = float(cameraNode\['far'].getValueAt(frame))\n    projection_mode = int(cameraNode\['projection_mode'].getValueAt(frame))\n    p = nuke.math.Matrix4()\n    p.projection(focal_length / h_aperture, near, far, projection_mode == 0)\n\n    # Matrix to translate the projected points into normalised pixel coords\n    imageAspect = float(imageformat.height()) / float(imageformat.width())\n    t = nuke.math.Matrix4()\n    t.makeIdentity()\n    t.translate(1.0, 1.0 - (1.0 - imageAspect / float(imageformat.pixelAspect())), 0.0)\n\n    # Matrix to scale normalised pixel coords into actual pixel coords.\n    x_scale = float(imageformat.width()) / 2.0\n    y_scale = x_scale * imageformat.pixelAspect()\n    s = nuke.math.Matrix4()\n    s.makeIdentity()\n    s.scale(x_scale, y_scale, 1.0)\n\n    return s * t * p * m * camTransform\n\n\ndef projectPoints(frame, camera=None, point=None, imageformat=None):\n    \"\"\"Project 3D points to 2D screen space\"\"\"\n    if not imageformat:\n        imageformat = nuke.root()\['format'].value()\n    camMatrix = cameraProjectionMatrix(camera, frame, imageformat)\n    if camMatrix is None:\n        raise RuntimeError('cameraProjectionMatrix() returned None for camera.')\n\n    if not isinstance(point, (list, tuple)):\n        raise ValueError('Argument point must be a list or tuple.')\n\n    for pt in point:\n        if isinstance(pt, nuke.math.Vector3):\n            pt = pt\n        elif isinstance(pt, (list, tuple)):\n            pt = nuke.math.Vector3(pt\[0], pt\[1], pt\[2])\n        else:\n            raise ValueError('All items in point must be nuke.math.Vector3 or list/tuple of 3 floats.')\n\n        tPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\n        try:\n            yield nuke.math.Vector2(tPos.x / tPos.w, tPos.y / tPos.w)\n        except ZeroDivisionError:\n            print('Zero Division Error on frame \{0\} with point data \{1\}'.format(frame, pt))\n            yield nuke.math.Vector2()\n\n\ndef getFrameRange(cam):\n    \"\"\"Get frame range from camera animation\"\"\"\n    first = None\n    last = None\n    \n    # Check translate animation\n    if cam\['translate'].isAnimated():\n        for curve in cam\['translate'].animations():\n            keys = curve.keys()\n            if keys:\n                frame_first = int(keys\[0].x)\n                frame_last = int(keys\[-1].x)\n                first = frame_first if first is None else min(first, frame_first)\n                last = frame_last if last is None else max(last, frame_last)\n    \n    # Check rotate animation\n    if cam\['rotate'].isAnimated():\n        for curve in cam\['rotate'].animations():\n            keys = curve.keys()\n            if keys:\n                frame_first = int(keys\[0].x)\n                frame_last = int(keys\[-1].x)\n                first = frame_first if first is None else min(first, frame_first)\n                last = frame_last if last is None else max(last, frame_last)\n    \n    # If no animation found, use root frame range\n    if first is None or last is None:\n        first = nuke.root().firstFrame()\n        last = nuke.root().lastFrame()\n        print(\"Camera not animated, using root frame range: \{\}-\{\}\".format(first, last))\n    else:\n        print(\"Using camera animation frame range: \{\}-\{\}\".format(first, last))\n    \n    return nuke.FrameRange('\{0\}-\{1\}'.format(first, last))\n\n\ndef reconcileLocatorsToTracker(camera_name=None):\n    \"\"\"Main function to reconcile selected locators to a Tracker4 node\"\"\"\n    \n    # CONFIGURATION - CHANGE THESE VALUES\n    if camera_name is None:\n        camera_name = \"Camera1\"  # Change this to your camera name\n    \n    # Get the camera node\n    try:\n        cam = nuke.toNode(camera_name)\n        if not cam or 'Camera' not in cam.Class():\n            nuke.message(\"Camera '\{\}' not found or is not a Camera node.\".format(camera_name))\n            return\n    except:\n        nuke.message(\"Camera '\{\}' not found.\".format(camera_name))\n        return\n    \n    # Get selected nodes and filter for Axis nodes (locators)\n    selected_nodes = nuke.selectedNodes()\n    locators = \[node for node in selected_nodes if 'Axis' in node.Class()]\n    \n    if not locators:\n        nuke.message(\"No Axis nodes (locators) selected. Please select your locator nodes.\")\n        return\n    \n    print(\"=\" * 50)\n    print(\"STEP 1: COLLECTING DATA\")\n    print(\"=\" * 50)\n    print(\"Found \{\} locators to reconcile\".format(len(locators)))\n    \n    # Print locator names for verification\n    for i, locator in enumerate(locators):\n        print(\"Locator \{\}: \{\}\".format(i+1, locator.name()))\n    \n    # Get frame range from camera\n    try:\n        framerange = getFrameRange(cam)\n        print(\"Frame range: \{\}\".format(framerange))\n    except Exception as e:\n        nuke.message(\"Error getting frame range: \{\}\".format(str(e)))\n        return\n    \n    # Get format\n    imageformat = nuke.root()\['format'].value()\n    print(\"Image format: \{\}x\{\}\".format(imageformat.width(), imageformat.height()))\n    \n    # STEP 1: Collect all projection data\n    print(\"\\n\" + \"=\" * 50)\n    print(\"STEP 2: PROJECTING LOCATORS\")\n    print(\"=\" * 50)\n    \n    locator_data = \[]\n    \n    for i, locator in enumerate(locators):\n        print(\"Processing locator \{\}/\{\}: \{\}\".format(i+1, len(locators), locator.name()))\n        \n        try:\n            # Get the locator's translate knob\n            translate_knob = locator\['translate']\n            \n            # Store locator info\n            locator_info = \{\n                'name': locator.name(),\n                'index': i,\n                'frames': \{\},\n                'success': True,\n                'error': None\n            \}\n            \n            # Build projection data for each frame\n            frame_count = 0\n            error_count = 0\n            \n            for frame in framerange:\n                try:\n                    # Sample locator position\n                    if translate_knob.isAnimated() or translate_knob.hasExpression():\n                        point_3d = translate_knob.getValueAt(frame)\n                    else:\n                        point_3d = translate_knob.value()\n                    \n                    # Project to 2D\n                    point_2d = next(projectPoints(frame, cam, \[point_3d], imageformat))\n                    \n                    # Store frame data\n                    locator_info\['frames']\[frame] = \{\n                        'point_3d': point_3d,\n                        'point_2d': (point_2d.x, point_2d.y),\n                        'success': True\n                    \}\n                    frame_count += 1\n                    \n                except Exception as e:\n                    locator_info\['frames']\[frame] = \{\n                        'point_3d': None,\n                        'point_2d': (0.0, 0.0),\n                        'success': False,\n                        'error': str(e)\n                    \}\n                    error_count += 1\n            \n            # Summary for this locator\n            print(\"  - Processed \{\} frames, \{\} errors\".format(frame_count, error_count))\n            if error_count > 0:\n                print(\"  - First few errors:\")\n                error_frames = \[f for f in locator_info\['frames'] if not locator_info\['frames']\[f]\['success']]\n                for ef in error_frames\[:3]:\n                    print(\"    Frame \{\}: \{\}\".format(ef, locator_info\['frames']\[ef]\['error']))\n            \n            locator_data.append(locator_info)\n            \n        except Exception as e:\n            print(\"  - FAILED: \{\}\".format(str(e)))\n            locator_info = \{\n                'name': locator.name(),\n                'index': i,\n                'frames': \{\},\n                'success': False,\n                'error': str(e)\n            \}\n            locator_data.append(locator_info)\n    \n    # STEP 2: Verify data collection\n    print(\"\\n\" + \"=\" * 50)\n    print(\"STEP 3: DATA VERIFICATION\")\n    print(\"=\" * 50)\n    \n    successful_locators = \[ld for ld in locator_data if ld\['success']]\n    failed_locators = \[ld for ld in locator_data if not ld\['success']]\n    \n    print(\"Successful locators: \{\}\".format(len(successful_locators)))\n    print(\"Failed locators: \{\}\".format(len(failed_locators)))\n    \n    if failed_locators:\n        print(\"Failed locator details:\")\n        for fl in failed_locators:\n            print(\"  - \{\}: \{\}\".format(fl\['name'], fl\['error']))\n    \n    if not successful_locators:\n        nuke.message(\"No locators were successfully processed!\")\n        return\n    \n    # Show some sample data\n    if successful_locators:\n        sample = successful_locators\[0]\n        sample_frames = list(sample\['frames'].keys())\[:3]\n        print(\"\\nSample data from '\{\}':\".format(sample\['name']))\n        for frame in sample_frames:\n            fd = sample\['frames']\[frame]\n            print(\"  Frame \{\}: 3D\{\} -> 2D\{\}\".format(\n                frame, fd\['point_3d'], fd\['point_2d']))\n    \n    # Ask user if they want to proceed\n    result = nuke.ask(\"Data collection complete!\\n\\n\"\n                     \"Successful: \{\} locators\\n\"\n                     \"Failed: \{\} locators\\n\\n\"\n                     \"Proceed to create Tracker4?\".format(\n                         len(successful_locators), len(failed_locators)))\n    \n    if not result:\n        print(\"User cancelled tracker creation.\")\n        return\n    \n    # STEP 3: Create Tracker4 and assign data using proper method\n    print(\"\\n\" + \"=\" * 50)\n    print(\"STEP 4: CREATING TRACKER4\")\n    print(\"=\" * 50)\n    \n    try:\n        # Create Tracker4 node\n        tracker_node = nuke.createNode('Tracker4')\n        tracker_node.setName('Reconciled_Tracker')\n        \n        # Get the number of tracks we need\n        num_tracks_needed = len(successful_locators)\n        print(\"Creating tracker with \{\} tracks\".format(num_tracks_needed))\n        \n        # Add tracks to Tracker4 node using the proper method\n        print(\"Adding tracks to Tracker4...\")\n        for track_idx in range(num_tracks_needed):\n            print(\"Adding track \{\}...\".format(track_idx + 1))\n            tracker_node.knob(\"add_track\").execute()\n        \n        # Get the tracks knob for setting data\n        tracks_knob = tracker_node.knob(\"tracks\")\n        if not tracks_knob:\n            raise RuntimeError(\"Could not find 'tracks' knob on Tracker4 node\")\n        \n        print(\"Setting track data using tracks knob...\")\n        tracks_assigned = 0\n        \n        # Process each successful locator\n        for track_idx, locator_info in enumerate(successful_locators):\n            print(\"Processing track \{\}: \{\}\".format(track_idx + 1, locator_info\['name']))\n            \n            frame_count = 0\n            error_count = 0\n            \n            # Process each frame in the locator data\n            for frame in sorted(locator_info\['frames'].keys()):\n                frame_data = locator_info\['frames']\[frame]\n                if frame_data\['success']:\n                    x, y = frame_data\['point_2d']\n                    \n                    # Try different indexing methods for setting track data\n                    success = False\n                    \n                    # Method 1: Standard indexing\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx, 0)\n                        tracks_knob.setValueAt(y, frame, track_idx, 1)\n                        success = True\n                    except:\n                        pass\n                    \n                    # Method 2: Alternative indexing (31-based)\n                    if not success:\n                        try:\n                            tracks_knob.setValueAt(x, frame, track_idx * 31 + 2)\n                            tracks_knob.setValueAt(y, frame, track_idx * 31 + 3)\n                            success = True\n                        except:\n                            pass\n                    \n                    # Method 3: 4-based indexing\n                    if not success:\n                        try:\n                            tracks_knob.setValueAt(x, frame, track_idx * 4 + 0)\n                            tracks_knob.setValueAt(y, frame, track_idx * 4 + 1)\n                            success = True\n                        except:\n                            pass\n                    \n                    # Method 4: 31-based alternative\n                    if not success:\n                        try:\n                            tracks_knob.setValueAt(x, frame, track_idx * 31 + 0)\n                            tracks_knob.setValueAt(y, frame, track_idx * 31 + 1)\n                            success = True\n                        except:\n                            pass\n                    \n                    if success:\n                        frame_count += 1\n                    else:\n                        error_count += 1\n                        if error_count <= 3:  # Only print first few errors\n                            print(\"  Warning: Could not set track data for track \{\} at frame \{\}\".format(track_idx, frame))\n            \n            if frame_count > 0:\n                tracks_assigned += 1\n                print(\"  - Successfully set \{\} frames (\{\} errors)\".format(frame_count, error_count))\n                \n                # Try to set track name if possible\n                try:\n                    # Some Tracker4 versions allow setting track names via the tracks knob\n                    # This might not work in all versions, so we'll try but not fail if it doesn't work\n                    track_name_idx = track_idx * 31 + 30  # Track name is often at offset 30\n                    tracks_knob.setValueAt(locator_info\['name'], 0, track_name_idx)\n                    print(\"  - Set track name to: \{\}\".format(locator_info\['name']))\n                except:\n                    # If setting name fails, that's okay - the track data is more important\n                    print(\"  - Could not set track name (this is normal for some Nuke versions)\")\n            else:\n                print(\"  - FAILED: No frames could be set for track \{\}\".format(track_idx))\n        \n        print(\"\\n\" + \"=\" * 50)\n        if tracks_assigned > 0:\n            print(\"SUCCESS!\")\n            print(\"=\" * 50)\n            print(\"Created tracker '\{\}' with \{\}/\{\} tracks assigned\".format(\n                tracker_node.name(), tracks_assigned, len(successful_locators)))\n            \n            # Print summary of what was created\n            print(\"\\nTrack Summary:\")\n            for i, locator_info in enumerate(successful_locators\[:tracks_assigned]):\n                frame_count = sum(1 for f in locator_info\['frames'].values() if f\['success'])\n                print(\"  Track \{\}: \{\} (\{\} keyframes)\".format(i+1, locator_info\['name'], frame_count))\n            \n            nuke.message(\"Reconciliation complete!\\n\\n\"\n                        \"Created tracker: \{\}\\n\"\n                        \"Assigned tracks: \{\}/\{\}\\n\"\n                        \"Failed locators: \{\}\\n\\n\"\n                        \"The tracker is ready to use!\".format(\n                            tracker_node.name(), \n                            tracks_assigned,\n                            len(successful_locators),\n                            len(failed_locators)))\n        else:\n            print(\"PARTIAL SUCCESS - TRACKER CREATED BUT NO TRACKS ASSIGNED\")\n            print(\"=\" * 50)\n            print(\"The tracker node was created but no tracks could be assigned.\")\n            print(\"This might be due to Nuke version differences in the Tracker4 API.\")\n            print(\"You may need to manually add tracks and copy the animation data.\")\n            \n            nuke.message(\"Tracker created but tracks not assigned!\\n\\n\"\n                        \"The tracker node '\{\}' was created but the automatic\\n\"\n                        \"track assignment failed. This may be due to Nuke version\\n\"\n                        \"differences. You'll need to manually add \{\} tracks.\".format(\n                            tracker_node.name(), len(successful_locators)))\n        \n    except Exception as e:\n        print(\"ERROR creating tracker: \{\}\".format(str(e)))\n        nuke.message(\"Error creating tracker: \{\}\".format(str(e)))\n        return\n\n\n# Alternative approach - Create tracks using a different method\ndef reconcileLocatorsToTrackerAlternative(camera_name=None):\n    \"\"\"Alternative method that creates a basic tracker and lets user manually add tracks\"\"\"\n    \n    # Same data collection as before...\n    if camera_name is None:\n        camera_name = \"Camera1\"\n    \n    try:\n        cam = nuke.toNode(camera_name)\n        if not cam or 'Camera' not in cam.Class():\n            nuke.message(\"Camera '\{\}' not found or is not a Camera node.\".format(camera_name))\n            return\n    except:\n        nuke.message(\"Camera '\{\}' not found.\".format(camera_name))\n        return\n    \n    selected_nodes = nuke.selectedNodes()\n    locators = \[node for node in selected_nodes if 'Axis' in node.Class()]\n    \n    if not locators:\n        nuke.message(\"No Axis nodes (locators) selected. Please select your locator nodes.\")\n        return\n    \n    # Quick data collection (abbreviated version)\n    print(\"Processing \{\} locators...\".format(len(locators)))\n    \n    framerange = getFrameRange(cam)\n    imageformat = nuke.root()\['format'].value()\n    \n    # Collect data\n    locator_data = \[]\n    for locator in locators:\n        translate_knob = locator\['translate']\n        locator_info = \{\n            'name': locator.name(),\n            'keyframes_x': \[],\n            'keyframes_y': \[]\n        \}\n        \n        for frame in framerange:\n            try:\n                if translate_knob.isAnimated() or translate_knob.hasExpression():\n                    point_3d = translate_knob.getValueAt(frame)\n                else:\n                    point_3d = translate_knob.value()\n                \n                point_2d = next(projectPoints(frame, cam, \[point_3d], imageformat))\n                \n                locator_info\['keyframes_x'].append(nuke.AnimationKey(frame, point_2d.x))\n                locator_info\['keyframes_y'].append(nuke.AnimationKey(frame, point_2d.y))\n                \n            except Exception as e:\n                print(\"Error on frame \{\} for \{\}: \{\}\".format(frame, locator.name(), str(e)))\n        \n        if locator_info\['keyframes_x']:  # Only add if we have data\n            locator_data.append(locator_info)\n    \n    if not locator_data:\n        nuke.message(\"No valid tracking data collected!\")\n        return\n    \n    # Create tracker and provide instructions\n    try:\n        tracker_node = nuke.createNode('Tracker4')\n        tracker_node.setName('Reconciled_Tracker_Manual')\n        \n        # Store the data in the tracker node as user knobs for manual application\n        instructions = \"INSTRUCTIONS:\\n\"\n        instructions += \"1. Right-click the tracker and select 'Add Track' \{\} times\\n\".format(len(locator_data))\n        instructions += \"2. For each track, copy the animation data shown below:\\n\\n\"\n        \n        for i, data in enumerate(locator_data):\n            instructions += \"Track \{\} (\{\}): \{\} keyframes\\n\".format(i+1, data\['name'], len(data\['keyframes_x']))\n        \n        # Add a text knob with instructions\n        instructions_knob = nuke.Text_Knob('instructions', 'Instructions', instructions)\n        tracker_node.addKnob(instructions_knob)\n        \n        # Store animation data as user knobs (for advanced users who want to script it)\n        for i, data in enumerate(locator_data):\n            # Create string representations of the keyframes\n            x_data = \[(key.x, key.y) for key in data\['keyframes_x']]\n            y_data = \[(key.x, key.y) for key in data\['keyframes_y']]\n            \n            x_knob = nuke.String_Knob('track\{\}_x_data'.format(i+1), 'Track \{\} X Data'.format(i+1), str(x_data))\n            y_knob = nuke.String_Knob('track\{\}_y_data'.format(i+1), 'Track \{\} Y Data'.format(i+1), str(y_data))\n            name_knob = nuke.String_Knob('track\{\}_name'.format(i+1), 'Track \{\} Name'.format(i+1), data\['name'])\n            \n            tracker_node.addKnob(x_knob)\n            tracker_node.addKnob(y_knob)\n            tracker_node.addKnob(name_knob)\n        \n        print(\"Created tracker with stored animation data\")\n        print(\"Check the tracker's properties panel for instructions and data\")\n        \n        nuke.message(\"Tracker created with animation data!\\n\\n\"\n                    \"The tracker '\{\}' has been created with all the\\n\"\n                    \"projected animation data stored as user knobs.\\n\\n\"\n                    \"Check the tracker's properties panel for instructions\\n\"\n                    \"on how to manually add the tracks and apply the data.\".format(tracker_node.name()))\n        \n    except Exception as e:\n        print(\"ERROR: \{\}\".format(str(e)))\n        nuke.message(\"Error: \{\}\".format(str(e)))\n\n\n# Alternative function if you want to specify locators by name pattern\ndef reconcileLocatorsByPattern(camera_name=\"Camera1\", locator_pattern=\"locator*\", use_selection=True):\n    \"\"\"Reconcile locators by name pattern instead of selection\n    \n    Args:\n        camera_name: Name of the camera node\n        locator_pattern: Pattern to match locator names (e.g., \"locator*\")\n        use_selection: If True, only consider selected nodes. If False, search all nodes.\n    \"\"\"\n    \n    # Get camera\n    try:\n        cam = nuke.toNode(camera_name)\n        if not cam or 'Camera' not in cam.Class():\n            nuke.message(\"Camera '\{\}' not found or is not a Camera node.\".format(camera_name))\n            return\n    except:\n        nuke.message(\"Camera '\{\}' not found.\".format(camera_name))\n        return\n    \n    # Find locators by pattern\n    locators = \[]\n    \n    if use_selection:\n        # Only search within selected nodes\n        search_nodes = nuke.selectedNodes()\n        print(\"Searching within \{\} selected nodes for pattern '\{\}'\".format(len(search_nodes), locator_pattern))\n    else:\n        # Search all nodes in the scene\n        search_nodes = nuke.allNodes()\n        print(\"Searching all \{\} nodes in scene for pattern '\{\}'\".format(len(search_nodes), locator_pattern))\n    \n    for node in search_nodes:\n        if 'Axis' in node.Class() and fnmatch.fnmatch(node.name(), locator_pattern):\n            locators.append(node)\n            print(\"Found matching locator: \{\}\".format(node.name()))\n    \n    if not locators:\n        if use_selection:\n            nuke.message(\"No selected locators found matching pattern '\{\}'\".format(locator_pattern))\n        else:\n            nuke.message(\"No locators found matching pattern '\{\}'\".format(locator_pattern))\n        return\n    \n    print(\"Found \{\} locators matching pattern '\{\}'\".format(len(locators), locator_pattern))\n    \n    # Temporarily select the found locators and run the main function\n    # Store current selection\n    original_selection = nuke.selectedNodes()\n    \n    # Clear selection and select found locators\n    for node in nuke.allNodes():\n        node.setSelected(False)\n    for locator in locators:\n        locator.setSelected(True)\n    \n    # Run reconciliation with specified camera\n    reconcileLocatorsToTracker(camera_name)\n    \n    # Restore original selection\n    for node in nuke.allNodes():\n        node.setSelected(False)\n    for node in original_selection:\n        node.setSelected(True)\n\n\nif __name__ == '__main__':\n    noop_node = nuke.thisNode()\n    cam = str(noop_node.knob(\"cam\").getValue())\n    loc = str(noop_node.knob(\"loc\").getValue())\n    # Main execution - choose one of these options:\n    \n    # Option 1: Use selected locators (improved version)\n    #reconcileLocatorsToTracker()\n    \n    # Option 2: Use pattern matching (uncomment and modify as needed)\n    reconcileLocatorsByPattern(cam, (loc+\"*\"), use_selection=True)\n    \n    # Option 3: Alternative method that creates tracker with stored data for manual assignment\n    #reconcileLocatorsToTrackerAlternative()\n    \n    # Option 4: Pattern matching with alternative method\n    # reconcileLocatorsByPattern(\"Camera1\", \"Axis*\")"}
addUserKnob {26 ""}
addUserKnob {26 _3 l "" +STARTLINE T "Locators2Tracker_PM v1.00 by Peter Mercell / 2025"}
addUserKnob {26 _2 l "" +STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.petermercell.com\" target=\"_blank\" rel=\"noopener\">www.petermercell.com</a>"}
}
