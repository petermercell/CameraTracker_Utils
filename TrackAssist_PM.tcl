set cut_paste_input [stack 0]
version 16.0 v4
push $cut_paste_input
NoOp {
name TrackAssist_PM1
tile_color 0xffff00ff
selected true
xpos 126
ypos 27
addUserKnob {20 User l TrackAssist_PM}
addUserKnob {26 ""}
addUserKnob {26 _1 l "" +STARTLINE T "1, Connect CameraTracker node (after Solve)\n2, Sample pixel in viewer\n3, Push calculate button"}
addUserKnob {26 ""}
addUserKnob {22 TEST l Calculate T "'''\nBASE CODE FROM MADS HAGBARTH\n================================================================================\n; Function:             ExportCameraTrack(myNode):\n; Description:          Extracts all 2D Tracking Features from a 3D CameraTracker node\n; Parameter(s):         myNode - A CameraTracker node containing tracking features\n; Return:               Output - A list of points formatted \[ \[\[Frame,X,Y]\[...]] \[\[...]\[...]] ]\n;                           \n; Note(s):              20/06/25 v008\n;=================================================================================='''\n\ndef ExportCameraTrack(myNode):\n    myKnob = myNode.knob(\"serializeKnob\")\n    myLines = myKnob.toScript()    \n    DataItems = myLines.split('\\n')\n    Output = \[]\n    \n    for index, line in enumerate(DataItems):\n        tempSplit = line.split(' ')\n        if (len(tempSplit) > 4 and tempSplit\[-1] == \"10\") or (len(tempSplit) > 6 and tempSplit\[-1] == \"10\"):\n            if len(tempSplit) > 6 and tempSplit\[6] == \"10\":\n                offsetKey = 2\n                offsetItem = 0\n            else:\n                offsetKey = 0\n                offsetItem = 0\n            itemHeader = DataItems\[index + 1]\n            itemHeadersplit = itemHeader.split(' ')\n            itemHeader_UniqueID = itemHeadersplit\[1]\n            if len(itemHeadersplit) == 3:\n                itemHeader = DataItems\[index + 2]\n                itemHeadersplit = itemHeader.split(' ')\n                offsetKey = 2\n                offsetItem = 2\n            itemHeader_FirstItem = itemHeadersplit\[3 + offsetItem]\n            itemHeader_NumberOfKeys = itemHeadersplit\[4 + offsetKey]\n            PositionList = \[]\n            for x in range(2, int(itemHeader_NumberOfKeys) + 1):\n                frame_line = DataItems\[index + x]\n                frame_parts = frame_line.split(' ')\n                PositionList.append(\[int(LastFrame) + (x - 2), frame_parts\[2], frame_parts\[3]])\n            Output.append(PositionList)\n        elif (len(tempSplit) > 8 and tempSplit\[1] == \"0\" and tempSplit\[2] == \"1\"):\n            LastFrame = tempSplit\[3]\n    print(f\"Exported \{len(Output)\} total tracks\")\n    return Output\n\ndef GrabListData(node):\n    \"\"\"\n    Optimized data structure for faster frame lookups\n    Returns: \[raw_tracks, frame_dict]\n    \"\"\"\n    #01: Get all points from the cameratracker node.\n    _return = ExportCameraTrack(node)\n\n    #02: To optimize the lookups we index all the data into frame lists containing \[x,y,index,firstframe,lastframe]\n    #     this will give a 40+ times performence boost.\n    item_dict = \{\}\n    for list_index, big_lst in enumerate(_return):\n        for lst in big_lst:\n            if lst\[0] in item_dict:\n                item_dict\[lst\[0]] += \[lst\[1:]+\[list_index]+\[_return\[list_index]\[0]\[0], _return\[list_index]\[len(_return\[list_index])-1]\[0]],] # Append\n            else:\n                item_dict\[lst\[0]] = \[lst\[1:]+\[list_index]+\[_return\[list_index]\[0]\[0], _return\[list_index]\[len(_return\[list_index])-1]\[0]],] # Initialize\n    return \[_return, item_dict]\n\n'''================================================================================\nAddTracksToTracker4 - Now integrated with GrabListData for optimized performance\n;=================================================================================='''\n\ndef AddTracksToTracker4(camera_tracker_node, start_frame, end_frame, max_tracks=50, longest_only=True):\n    \"\"\"\n    Create a Tracker4 node from CameraTracker data using optimized frame lookups\n    \n    Args:\n        camera_tracker_node: The CameraTracker node to extract data from\n        start_frame: First frame to process\n        end_frame: Last frame to process\n        max_tracks: Maximum number of tracks to create\n        longest_only: If True, prioritize longest tracks\n    \"\"\"\n    # Get optimized data structure\n    raw_tracks, frame_dict = GrabListData(camera_tracker_node)\n    \n    # Create new Tracker4 node\n    tracker_node = nuke.createNode(\"Tracker4\")\n    tracker_node.setName(\"CameraTracker_Converted\")\n\n    # Filter tracks based on length if requested\n    if longest_only:\n        tracks_with_length = \[(len(track), track) for track in raw_tracks]\n        tracks_with_length.sort(key=lambda x: x\[0], reverse=True)\n        filtered_tracks = \[track for length, track in tracks_with_length\[:max_tracks]]\n    else:\n        filtered_tracks = raw_tracks\[:max_tracks]\n\n    print(f\"Creating \{len(filtered_tracks)\} tracks in Tracker4 node\")\n\n    # Add tracks to Tracker4 node\n    for track_idx, track in enumerate(filtered_tracks):\n        tracker_node.knob(\"add_track\").execute()\n        tracks_knob = tracker_node.knob(\"tracks\")\n        \n        # Process each frame in the track\n        for frame_data in track:\n            frame = frame_data\[0]\n            if start_frame <= frame <= end_frame:\n                x = float(frame_data\[1])\n                y = float(frame_data\[2])\n                \n                # Try different indexing methods for setting track data\n                success = False\n                \n                # Method 1: Standard indexing\n                try:\n                    tracks_knob.setValueAt(x, frame, track_idx, 0)\n                    tracks_knob.setValueAt(y, frame, track_idx, 1)\n                    success = True\n                except:\n                    pass\n                \n                # Method 2: Alternative indexing (31-based)\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 31 + 2)\n                        tracks_knob.setValueAt(y, frame, track_idx * 31 + 3)\n                        success = True\n                    except:\n                        pass\n                \n                # Method 3: 4-based indexing\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 4 + 0)\n                        tracks_knob.setValueAt(y, frame, track_idx * 4 + 1)\n                        success = True\n                    except:\n                        pass\n                \n                # Method 4: 31-based alternative\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 31 + 0)\n                        tracks_knob.setValueAt(y, frame, track_idx * 31 + 1)\n                        success = True\n                    except:\n                        pass\n                \n                if not success:\n                    print(f\"Warning: Could not set track data for track \{track_idx\} at frame \{frame\}\")\n\n    print(f\"Successfully created Tracker4 node with \{len(filtered_tracks)\} tracks\")\n    return tracker_node\n\ndef AddTracksToTracker4_WithFrameDict(camera_tracker_node, start_frame, end_frame, max_tracks=50, longest_only=True):\n    \"\"\"\n    Alternative version that uses the frame dictionary for even faster lookups\n    when you need to process specific frame ranges efficiently\n    \"\"\"\n    # Get optimized data structure\n    raw_tracks, frame_dict = GrabListData(camera_tracker_node)\n    \n    # Create new Tracker4 node\n    tracker_node = nuke.createNode(\"Tracker4\")\n    tracker_node.setName(\"CameraTracker_Converted_FrameDict\")\n\n    # Filter tracks based on length if requested\n    if longest_only:\n        tracks_with_length = \[(len(track), track) for track in raw_tracks]\n        tracks_with_length.sort(key=lambda x: x\[0], reverse=True)\n        filtered_tracks = \[track for length, track in tracks_with_length\[:max_tracks]]\n    else:\n        filtered_tracks = raw_tracks\[:max_tracks]\n\n    # Create a mapping of track indices for the filtered tracks\n    track_indices = \{\}\n    for i, track in enumerate(filtered_tracks):\n        # Find the original track index\n        for orig_idx, orig_track in enumerate(raw_tracks):\n            if track == orig_track:\n                track_indices\[orig_idx] = i\n                break\n\n    print(f\"Creating \{len(filtered_tracks)\} tracks using frame dictionary optimization\")\n\n    # Add tracks using frame dictionary for faster lookups\n    for track_idx in range(len(filtered_tracks)):\n        tracker_node.knob(\"add_track\").execute()\n    \n    tracks_knob = tracker_node.knob(\"tracks\")\n    \n    # Process frame by frame using the optimized dictionary\n    for frame in range(start_frame, end_frame + 1):\n        if frame in frame_dict:\n            frame_data = frame_dict\[frame]\n            for data_point in frame_data:\n                # data_point format: \[x, y, original_track_index, first_frame, last_frame]\n                x, y, orig_track_idx = float(data_point\[0]), float(data_point\[1]), data_point\[2]\n                \n                # Check if this track is in our filtered selection\n                if orig_track_idx in track_indices:\n                    new_track_idx = track_indices\[orig_track_idx]\n                    \n                    # Set the track data\n                    success = False\n                    try:\n                        tracks_knob.setValueAt(x, frame, new_track_idx, 0)\n                        tracks_knob.setValueAt(y, frame, new_track_idx, 1)\n                        success = True\n                    except:\n                        # Try alternative indexing methods if needed\n                        try:\n                            tracks_knob.setValueAt(x, frame, new_track_idx * 31 + 2)\n                            tracks_knob.setValueAt(y, frame, new_track_idx * 31 + 3)\n                            success = True\n                        except:\n                            pass\n                    \n                    if not success:\n                        print(f\"Warning: Could not set track data for track \{new_track_idx\} at frame \{frame\}\")\n\n    print(f\"Successfully created Tracker4 node with \{len(filtered_tracks)\} tracks using frame dictionary\")\n    return tracker_node\n\n# Usage Examples:\n# Method 1: Standard integration (recommended for most cases)\ncamera_tracker = nuke.toNode(\"CameraTracker1\")\n#tracker_node = AddTracksToTracker4(camera_tracker, start_frame=1, end_frame=50, max_tracks=30, longest_only=True)\n\n# Method 2(TOTO JE DOBRE): Frame dictionary optimization (for very large datasets or specific frame processing)\n#tracker_node_optimized = AddTracksToTracker4_WithFrameDict(camera_tracker, start_frame=1, end_frame=50, max_tracks=30, longest_only=True)\n\n'''================================================================================\nInstant Track Finder - Find closest track to any X,Y position at any frame\nUses optimized frame dictionary for instant lookups\n;=================================================================================='''\n\nimport math\n\nclass InstantTrackFinder:\n    def __init__(self, camera_tracker_node):\n        \"\"\"Initialize with CameraTracker data\"\"\"\n        self.raw_tracks, self.frame_dict = GrabListData(camera_tracker_node)\n        self.node = camera_tracker_node\n        print(f\"Initialized InstantTrackFinder with \{len(self.raw_tracks)\} tracks\")\n        print(f\"Available frames: \{sorted(self.frame_dict.keys())\[:10]\}...\" if self.frame_dict else \"No frame data\")\n    \n    def calculate_track_for_position(self, target_x, target_y, target_frame, method=\"planar_transform\", search_radius=200.0, min_tracks=3):\n        \"\"\"\n        Calculate/interpolate a track for a position where no direct track exists\n        Uses nearby tracks to estimate motion at the target position\n        \n        Args:\n            target_x, target_y: Desired position\n            target_frame: Frame to calculate for\n            method: \"planar_transform\", \"average_motion\", or \"closest_extrapolate\"\n            search_radius: How far to look for reference tracks\n            min_tracks: Minimum tracks needed for calculation\n            \n        Returns:\n            dict: \{\n                'calculated_track': list,     # Full calculated track data \[\[frame,x,y],...]\n                'method_used': str,           # Which calculation method was used\n                'reference_tracks': list,     # Tracks used for calculation\n                'confidence': float,          # Confidence score 0-1\n                'frame_range': tuple          # (start_frame, end_frame)\n            \}\n        \"\"\"\n        \n        # Find reference tracks near the target position\n        reference_tracks = self.find_all_tracks_in_radius(target_x, target_y, target_frame, search_radius)\n        \n        if len(reference_tracks) < min_tracks:\n            # Expand search or try closest tracks\n            print(f\"Only found \{len(reference_tracks)\} tracks within \{search_radius\}px, expanding search...\")\n            reference_tracks = self.get_closest_n_tracks(target_x, target_y, target_frame, n=min_tracks)\n        \n        if len(reference_tracks) < 2:\n            print(\"Not enough reference tracks found for calculation\")\n            return None\n        \n        print(f\"Using \{len(reference_tracks)\} reference tracks for calculation\")\n        \n        # Get frame range from reference tracks\n        all_frames = set()\n        for ref_track in reference_tracks:\n            for frame_data in ref_track\['track_data']:\n                all_frames.add(frame_data\[0])\n        \n        frame_range = (min(all_frames), max(all_frames))\n        \n        if method == \"planar_transform\":\n            result = self._calculate_planar_transform(target_x, target_y, target_frame, reference_tracks, all_frames)\n        elif method == \"average_motion\":\n            result = self._calculate_average_motion(target_x, target_y, target_frame, reference_tracks, all_frames)\n        else:  # closest_extrapolate\n            result = self._calculate_closest_extrapolate(target_x, target_y, target_frame, reference_tracks, all_frames)\n        \n        if result:\n            result.update(\{\n                'method_used': method,\n                'reference_tracks': reference_tracks,\n                'frame_range': frame_range\n            \})\n        \n        return result\n    \n    def get_closest_n_tracks(self, x, y, frame, n=5):\n        \"\"\"Get the N closest tracks to a position, regardless of distance\"\"\"\n        if frame not in self.frame_dict:\n            return \[]\n        \n        all_tracks = \[]\n        for track_point in self.frame_dict\[frame]:\n            track_x = float(track_point\[0])\n            track_y = float(track_point\[1])\n            track_index = track_point\[2]\n            first_frame = track_point\[3]\n            last_frame = track_point\[4]\n            \n            distance = math.sqrt((x - track_x)**2 + (y - track_y)**2)\n            \n            all_tracks.append(\{\n                'track_index': track_index,\n                'distance': distance,\n                'track_x': track_x,\n                'track_y': track_y,\n                'track_data': self.raw_tracks\[track_index],\n                'frame_range': (first_frame, last_frame)\n            \})\n        \n        all_tracks.sort(key=lambda x: x\['distance'])\n        return all_tracks\[:n]\n    \n    def _calculate_average_motion(self, target_x, target_y, target_frame, reference_tracks, all_frames):\n        \"\"\"Calculate track using weighted average of nearby track motions\"\"\"\n        calculated_track = \[]\n        \n        # Weight tracks by inverse distance\n        weights = \[]\n        total_weight = 0\n        for ref_track in reference_tracks:\n            weight = 1.0 / (ref_track\['distance'] + 1.0)  # +1 to avoid division by zero\n            weights.append(weight)\n            total_weight += weight\n        \n        # Normalize weights\n        weights = \[w / total_weight for w in weights]\n        \n        for frame in sorted(all_frames):\n            # Get offset from target frame for each reference track\n            weighted_offset_x = 0\n            weighted_offset_y = 0\n            valid_tracks = 0\n            \n            for i, ref_track in enumerate(reference_tracks):\n                # Find this track's position at target_frame and current frame\n                target_pos = self.get_track_at_frame(ref_track\['track_index'], target_frame)\n                current_pos = self.get_track_at_frame(ref_track\['track_index'], frame)\n                \n                if target_pos and current_pos:\n                    # Calculate motion vector\n                    motion_x = current_pos\['x'] - target_pos\['x']\n                    motion_y = current_pos\['y'] - target_pos\['y']\n                    \n                    # Apply weight\n                    weighted_offset_x += motion_x * weights\[i]\n                    weighted_offset_y += motion_y * weights\[i]\n                    valid_tracks += 1\n            \n            if valid_tracks > 0:\n                # Calculate final position\n                final_x = target_x + weighted_offset_x\n                final_y = target_y + weighted_offset_y\n                calculated_track.append(\[frame, final_x, final_y])\n        \n        confidence = min(1.0, len(reference_tracks) / 5.0) * (valid_tracks / len(all_frames))\n        \n        return \{\n            'calculated_track': calculated_track,\n            'confidence': confidence\n        \}\n    \n    def _calculate_closest_extrapolate(self, target_x, target_y, target_frame, reference_tracks, all_frames):\n        \"\"\"Use the closest track and offset it to target position\"\"\"\n        closest_track = reference_tracks\[0]  # Already sorted by distance\n        \n        # Get the offset between target position and closest track at target frame\n        target_pos = self.get_track_at_frame(closest_track\['track_index'], target_frame)\n        if not target_pos:\n            return None\n        \n        offset_x = target_x - target_pos\['x']\n        offset_y = target_y - target_pos\['y']\n        \n        calculated_track = \[]\n        for frame_data in closest_track\['track_data']:\n            frame = frame_data\[0]\n            orig_x = float(frame_data\[1])\n            orig_y = float(frame_data\[2])\n            \n            new_x = orig_x + offset_x\n            new_y = orig_y + offset_y\n            calculated_track.append(\[frame, new_x, new_y])\n        \n        confidence = max(0.3, 1.0 - (closest_track\['distance'] / 100.0))  # Decrease confidence with distance\n        \n        return \{\n            'calculated_track': calculated_track,\n            'confidence': confidence\n        \}\n    \n    def _calculate_planar_transform(self, target_x, target_y, target_frame, reference_tracks, all_frames):\n        \"\"\"Calculate using planar transformation from multiple reference points\"\"\"\n        if len(reference_tracks) < 3:\n            # Fall back to average motion\n            return self._calculate_average_motion(target_x, target_y, target_frame, reference_tracks, all_frames)\n        \n        # This is a simplified version - for full planar transform you'd need more complex math\n        # For now, use weighted average with better distribution weighting\n        calculated_track = \[]\n        \n        for frame in sorted(all_frames):\n            positions = \[]\n            weights = \[]\n            \n            for ref_track in reference_tracks:\n                current_pos = self.get_track_at_frame(ref_track\['track_index'], frame)\n                target_pos = self.get_track_at_frame(ref_track\['track_index'], target_frame)\n                \n                if current_pos and target_pos:\n                    # Calculate relative motion\n                    motion_x = current_pos\['x'] - target_pos\['x']\n                    motion_y = current_pos\['y'] - target_pos\['y']\n                    \n                    # Weight by inverse distance and track quality\n                    weight = 1.0 / (ref_track\['distance'] + 10.0)\n                    \n                    positions.append((motion_x, motion_y))\n                    weights.append(weight)\n            \n            if positions:\n                # Weighted average\n                total_weight = sum(weights)\n                avg_motion_x = sum(pos\[0] * w for pos, w in zip(positions, weights)) / total_weight\n                avg_motion_y = sum(pos\[1] * w for pos, w in zip(positions, weights)) / total_weight\n                \n                final_x = target_x + avg_motion_x\n                final_y = target_y + avg_motion_y\n                calculated_track.append(\[frame, final_x, final_y])\n        \n        confidence = min(1.0, len(reference_tracks) / 8.0) * min(1.0, len(calculated_track) / len(all_frames))\n        \n        return \{\n            'calculated_track': calculated_track,\n            'confidence': confidence\n        \}\n        \"\"\"\n        Find the closest track to given X,Y position at specific frame\n        \n        Args:\n            x, y: Screen coordinates to search near\n            frame: Frame number to search at\n            max_distance: Maximum pixel distance to consider (default: 50)\n            \n        Returns:\n            dict: \{\n                'track_index': int,           # Original track index\n                'distance': float,            # Distance in pixels\n                'track_x': float,             # Actual track X position\n                'track_y': float,             # Actual track Y position\n                'track_data': list,           # Full track data for this track\n                'frame_range': tuple          # (first_frame, last_frame) for this track\n            \}\n            or None if no track found within max_distance\n        \"\"\"\n        if frame not in self.frame_dict:\n            return None\n        \n        closest_track = None\n        min_distance = float('inf')\n        \n        # Check all tracks available at this frame\n        for track_point in self.frame_dict\[frame]:\n            # track_point format: \[x, y, track_index, first_frame, last_frame]\n            track_x = float(track_point\[0])\n            track_y = float(track_point\[1])\n            track_index = track_point\[2]\n            first_frame = track_point\[3]\n            last_frame = track_point\[4]\n            \n            # Calculate distance\n            distance = math.sqrt((x - track_x)**2 + (y - track_y)**2)\n            \n            if distance < min_distance and distance <= max_distance:\n                min_distance = distance\n                closest_track = \{\n                    'track_index': track_index,\n                    'distance': distance,\n                    'track_x': track_x,\n                    'track_y': track_y,\n                    'track_data': self.raw_tracks\[track_index],\n                    'frame_range': (first_frame, last_frame)\n                \}\n        \n        return closest_track\n    \n    def find_all_tracks_in_radius(self, x, y, frame, radius=30.0):\n        \"\"\"\n        Find all tracks within a radius of X,Y position at specific frame\n        \n        Returns:\n            list: List of track dictionaries sorted by distance\n        \"\"\"\n        if frame not in self.frame_dict:\n            return \[]\n        \n        tracks_in_radius = \[]\n        \n        for track_point in self.frame_dict\[frame]:\n            track_x = float(track_point\[0])\n            track_y = float(track_point\[1])\n            track_index = track_point\[2]\n            first_frame = track_point\[3]\n            last_frame = track_point\[4]\n            \n            distance = math.sqrt((x - track_x)**2 + (y - track_y)**2)\n            \n            if distance <= radius:\n                tracks_in_radius.append(\{\n                    'track_index': track_index,\n                    'distance': distance,\n                    'track_x': track_x,\n                    'track_y': track_y,\n                    'track_data': self.raw_tracks\[track_index],\n                    'frame_range': (first_frame, last_frame)\n                \})\n        \n        # Sort by distance\n        tracks_in_radius.sort(key=lambda x: x\['distance'])\n        return tracks_in_radius\n    \n    def get_track_at_frame(self, track_index, frame):\n        \"\"\"\n        Get specific track position at specific frame\n        \n        Returns:\n            dict: \{'x': float, 'y': float\} or None if track doesn't exist at frame\n        \"\"\"\n        if track_index >= len(self.raw_tracks):\n            return None\n        \n        track_data = self.raw_tracks\[track_index]\n        for frame_data in track_data:\n            if frame_data\[0] == frame:\n                return \{\n                    'x': float(frame_data\[1]),\n                    'y': float(frame_data\[2])\n                \}\n        return None\n    \n    def create_calculated_tracker(self, target_x, target_y, target_frame, method=\"average_motion\", track_name=\"CalculatedTrack\"):\n        \"\"\"\n        Create a Tracker4 node with a calculated track for the target position\n        \"\"\"\n        result = self.calculate_track_for_position(target_x, target_y, target_frame, method)\n        \n        if not result:\n            print(f\"Could not calculate track for position (\{target_x\}, \{target_y\}) at frame \{target_frame\}\")\n            return None\n        \n        # Create new Tracker4 node\n        tracker_node = nuke.createNode(\"Tracker4\")\n        tracker_node.setName(track_name)\n        \n        # Add one track\n        tracker_node.knob(\"add_track\").execute()\n        tracks_knob = tracker_node.knob(\"tracks\")\n        \n        # Set the calculated track data\n        calculated_track = result\['calculated_track']\n        for frame_data in calculated_track:\n            frame_num = frame_data\[0]\n            track_x = float(frame_data\[1])\n            track_y = float(frame_data\[2])\n            \n            try:\n                tracks_knob.setValueAt(track_x, frame_num, 0, 0)  # X position\n                tracks_knob.setValueAt(track_y, frame_num, 0, 1)  # Y position\n            except:\n                try:\n                    tracks_knob.setValueAt(track_x, frame_num, 2)   # Alternative indexing\n                    tracks_knob.setValueAt(track_y, frame_num, 3)\n                except:\n                    pass\n        \n        print(f\"Created calculated tracker '\{track_name\}' using \{result\['method_used']\}\")\n        print(f\"Confidence: \{result\['confidence']:.2f\}\")\n        print(f\"Based on \{len(result\['reference_tracks'])\} reference tracks\")\n        print(f\"Track range: frames \{result\['frame_range']\[0]\}-\{result\['frame_range']\[1]\}\")\n        \n        return tracker_node\n\n    def find_closest_track(self, x, y, frame, max_distance=50.0):\n        \"\"\"\n        Create a new Tracker4 node with the closest track to given position\n        \n        Returns:\n            nuke.Node: New Tracker4 node with the selected track\n        \"\"\"\n        closest = self.find_closest_track(x, y, frame, search_radius)\n        \n        if not closest:\n            print(f\"No track found within \{search_radius\} pixels of position (\{x\}, \{y\}) at frame \{frame\}\")\n            return None\n        \n        # Create new Tracker4 node\n        tracker_node = nuke.createNode(\"Tracker4\")\n        tracker_node.setName(track_name)\n        \n        # Add one track\n        tracker_node.knob(\"add_track\").execute()\n        tracks_knob = tracker_node.knob(\"tracks\")\n        \n        # Set the track data\n        track_data = closest\['track_data']\n        for frame_data in track_data:\n            frame_num = frame_data\[0]\n            track_x = float(frame_data\[1])\n            track_y = float(frame_data\[2])\n            \n            try:\n                tracks_knob.setValueAt(track_x, frame_num, 0, 0)  # X position\n                tracks_knob.setValueAt(track_y, frame_num, 0, 1)  # Y position\n            except:\n                try:\n                    tracks_knob.setValueAt(track_x, frame_num, 2)   # Alternative indexing\n                    tracks_knob.setValueAt(track_y, frame_num, 3)\n                except:\n                    pass\n        \n        print(f\"Created tracker '\{track_name\}' with track \{closest\['track_index']\}\")\n        print(f\"Track range: frames \{closest\['frame_range']\[0]\}-\{closest\['frame_range']\[1]\}\")\n        print(f\"Distance from clicked position: \{closest\['distance']:.1f\} pixels\")\n        \n        return tracker_node\n\n# Convenience functions for easy usage\ndef create_instant_track_finder(camera_tracker_node_name=\"CameraTracker1\"):\n    \"\"\"Create an InstantTrackFinder instance\"\"\"\n    node = nuke.toNode(camera_tracker_node_name)\n    if not node:\n        print(f\"Error: Node '\{camera_tracker_node_name\}' not found\")\n        return None\n    return InstantTrackFinder(node)\n\n# Convenience functions for calculated tracks\ndef create_calculated_track(target_x, target_y, target_frame, camera_tracker_node_name=\"CameraTracker1\", method=\"average_motion\"):\n    \"\"\"Quick function to create calculated tracker\"\"\"\n    finder = create_instant_track_finder(camera_tracker_node_name)\n    if finder:\n        return finder.create_calculated_tracker(target_x, target_y, target_frame, method)\n    return None\n\ndef find_track_at_position(x, y, frame, camera_tracker_node_name=\"CameraTracker1\", max_distance=50.0):\n    \"\"\"Quick function to find closest track\"\"\"\n    finder = create_instant_track_finder(camera_tracker_node_name)\n    if finder:\n        return finder.find_closest_track(x, y, frame, max_distance)\n    return None\n\ndef create_tracker_from_click(x, y, frame, camera_tracker_node_name=\"CameraTracker1\", search_radius=30.0):\n    \"\"\"Quick function to create tracker from position\"\"\"\n    finder = create_instant_track_finder(camera_tracker_node_name)\n    if finder:\n        return finder.create_tracker_from_position(x, y, frame, search_radius)\n    return None\n\n'''================================================================================\nUsage Examples:\n;=================================================================================='''\n\nFrame = nuke.frame()\n    \ndef Position2D():\n    viewer = nuke.activeViewer()\n    activeInput = nuke.ViewerWindow.activeInput(viewer)\n    viewerNode = viewer.node()\n    sampledImage = viewerNode.input(activeInput)\n    bboxinfo = viewer.node()\['colour_sample_bbox'].value()\n    aspect = float(sampledImage.width()) / float(sampledImage.height())\n    position = \[(bboxinfo\[0] * 0.5 + 0.5) * sampledImage.width(), \n                (((bboxinfo\[1] * 0.5) + (0.5 / aspect)) * aspect) * sampledImage.height()]\n    return position\n\n# Example 1: Calculate track for position with no existing track\ndef example_calculate_track():\n    noop_node = nuke.thisNode()\n    #print(noop_node.input(0).name())\n    Frame = nuke.frame()\n    CameraTrackerName = str(noop_node.input(0).name())\n    target_x = int(Position2D()\[0])\n    target_y = int(Position2D()\[1])\n    target_frame = int(nuke.frame())\n    finder = create_instant_track_finder(CameraTrackerName)\n    \n    # Try to calculate a track for position (500, 300) at frame 25\n    result = finder.calculate_track_for_position(\n        target_x, \n        target_y, \n        target_frame,\n        method=\"planar_transform\",\n        search_radius=200.0\n    )\n    \n    if result:\n        print(f\"Successfully calculated track using \{result\['method_used']\}\")\n        print(f\"Confidence: \{result\['confidence']:.2f\}\")\n        print(f\"Track has \{len(result\['calculated_track'])\} keyframes\")\n        print(f\"Used \{len(result\['reference_tracks'])\} reference tracks\")\n        \n        # Create the tracker node\n        tracker = finder.create_calculated_tracker(target_x, target_y, target_frame, method=\"planar_transform\")\n        \n    else:\n        print(\"Could not calculate track - not enough reference data\")\n\n# Example 3: Compare different calculation methods\ndef example_compare_methods():\n    finder = create_instant_track_finder(\"CameraTracker1\")\n    x, y, frame = 338, 453, 27\n    \n    methods = \[\"average_motion\", \"closest_extrapolate\", \"planar_transform\"]\n    \n    for method in methods:\n        print(f\"\\n--- Testing \{method\} ---\")\n        result = finder.calculate_track_for_position(x, y, frame, method=method)\n        if result:\n            print(f\"Confidence: \{result\['confidence']:.2f\}\")\n            print(f\"Track points: \{len(result\['calculated_track'])\}\")\n        else:\n            print(\"Failed to calculate\")\n\ndef example_find_closest():\n    finder = create_instant_track_finder(\"CameraTracker1\")\n    result = finder.find_closest_track(x=338, y=453, frame=27)\n    \n    if result:\n        print(f\"Found track \{result\['track_index']\} at distance \{result\['distance']:.1f\}\")\n        print(f\"Track position: (\{result\['track_x']:.1f\}, \{result\['track_y']:.1f\})\")\n        print(f\"Track active from frame \{result\['frame_range']\[0]\} to \{result\['frame_range']\[1]\}\")\n    else:\n        print(\"No track found\")\n\n# Quick test with calculated tracks\nexample_calculate_track()\n# example_compare_methods()" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {3 start_frame l "start frame"}
start_frame 1
addUserKnob {3 end_frame l "end frame" -STARTLINE}
end_frame 50
addUserKnob {3 max_tracks l "max tracks" -STARTLINE}
max_tracks 10
addUserKnob {26 ""}
addUserKnob {22 alltracks l "Export ALL tracks" T "'''\nBASE CODE FROM MADS HAGBARTH\n================================================================================\n; Function:             ExportCameraTrack(myNode):\n; Description:          Extracts all 2D Tracking Features from a 3D CameraTracker node\n; Parameter(s):         myNode - A CameraTracker node containing tracking features\n; Return:               Output - A list of points formatted \[ \[\[Frame,X,Y]\[...]] \[\[...]\[...]] ]\n;                           \n; Note(s):              20/06/25 v008\n;=================================================================================='''\n\ndef ExportCameraTrack(myNode):\n    myKnob = myNode.knob(\"serializeKnob\")\n    myLines = myKnob.toScript()    \n    DataItems = myLines.split('\\n')\n    Output = \[]\n    \n    for index, line in enumerate(DataItems):\n        tempSplit = line.split(' ')\n        if (len(tempSplit) > 4 and tempSplit\[-1] == \"10\") or (len(tempSplit) > 6 and tempSplit\[-1] == \"10\"):\n            if len(tempSplit) > 6 and tempSplit\[6] == \"10\":\n                offsetKey = 2\n                offsetItem = 0\n            else:\n                offsetKey = 0\n                offsetItem = 0\n            itemHeader = DataItems\[index + 1]\n            itemHeadersplit = itemHeader.split(' ')\n            itemHeader_UniqueID = itemHeadersplit\[1]\n            if len(itemHeadersplit) == 3:\n                itemHeader = DataItems\[index + 2]\n                itemHeadersplit = itemHeader.split(' ')\n                offsetKey = 2\n                offsetItem = 2\n            itemHeader_FirstItem = itemHeadersplit\[3 + offsetItem]\n            itemHeader_NumberOfKeys = itemHeadersplit\[4 + offsetKey]\n            PositionList = \[]\n            for x in range(2, int(itemHeader_NumberOfKeys) + 1):\n                frame_line = DataItems\[index + x]\n                frame_parts = frame_line.split(' ')\n                PositionList.append(\[int(LastFrame) + (x - 2), frame_parts\[2], frame_parts\[3]])\n            Output.append(PositionList)\n        elif (len(tempSplit) > 8 and tempSplit\[1] == \"0\" and tempSplit\[2] == \"1\"):\n            LastFrame = tempSplit\[3]\n    print(f\"Exported \{len(Output)\} total tracks\")\n    return Output\n\ndef GrabListData(node):\n    \"\"\"\n    Optimized data structure for faster frame lookups\n    Returns: \[raw_tracks, frame_dict]\n    \"\"\"\n    #01: Get all points from the cameratracker node.\n    _return = ExportCameraTrack(node)\n\n    #02: To optimize the lookups we index all the data into frame lists containing \[x,y,index,firstframe,lastframe]\n    #     this will give a 40+ times performence boost.\n    item_dict = \{\}\n    for list_index, big_lst in enumerate(_return):\n        for lst in big_lst:\n            if lst\[0] in item_dict:\n                item_dict\[lst\[0]] += \[lst\[1:]+\[list_index]+\[_return\[list_index]\[0]\[0], _return\[list_index]\[len(_return\[list_index])-1]\[0]],] # Append\n            else:\n                item_dict\[lst\[0]] = \[lst\[1:]+\[list_index]+\[_return\[list_index]\[0]\[0], _return\[list_index]\[len(_return\[list_index])-1]\[0]],] # Initialize\n    return \[_return, item_dict]\n\n'''================================================================================\nAddTracksToTracker4 - Now integrated with GrabListData for optimized performance\n;=================================================================================='''\n\ndef AddTracksToTracker4(camera_tracker_node, start_frame, end_frame, max_tracks=50, longest_only=True):\n    \"\"\"\n    Create a Tracker4 node from CameraTracker data using optimized frame lookups\n    \n    Args:\n        camera_tracker_node: The CameraTracker node to extract data from\n        start_frame: First frame to process\n        end_frame: Last frame to process\n        max_tracks: Maximum number of tracks to create\n        longest_only: If True, prioritize longest tracks\n    \"\"\"\n    # Get optimized data structure\n    raw_tracks, frame_dict = GrabListData(camera_tracker_node)\n    \n    # Create new Tracker4 node\n    tracker_node = nuke.createNode(\"Tracker4\")\n    tracker_node.setName(\"CameraTracker_Converted\")\n\n    # Filter tracks based on length if requested\n    if longest_only:\n        tracks_with_length = \[(len(track), track) for track in raw_tracks]\n        tracks_with_length.sort(key=lambda x: x\[0], reverse=True)\n        filtered_tracks = \[track for length, track in tracks_with_length\[:max_tracks]]\n    else:\n        filtered_tracks = raw_tracks\[:max_tracks]\n\n    print(f\"Creating \{len(filtered_tracks)\} tracks in Tracker4 node\")\n\n    # Add tracks to Tracker4 node\n    for track_idx, track in enumerate(filtered_tracks):\n        tracker_node.knob(\"add_track\").execute()\n        tracks_knob = tracker_node.knob(\"tracks\")\n        \n        # Process each frame in the track\n        for frame_data in track:\n            frame = frame_data\[0]\n            if start_frame <= frame <= end_frame:\n                x = float(frame_data\[1])\n                y = float(frame_data\[2])\n                \n                # Try different indexing methods for setting track data\n                success = False\n                \n                # Method 1: Standard indexing\n                try:\n                    tracks_knob.setValueAt(x, frame, track_idx, 0)\n                    tracks_knob.setValueAt(y, frame, track_idx, 1)\n                    success = True\n                except:\n                    pass\n                \n                # Method 2: Alternative indexing (31-based)\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 31 + 2)\n                        tracks_knob.setValueAt(y, frame, track_idx * 31 + 3)\n                        success = True\n                    except:\n                        pass\n                \n                # Method 3: 4-based indexing\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 4 + 0)\n                        tracks_knob.setValueAt(y, frame, track_idx * 4 + 1)\n                        success = True\n                    except:\n                        pass\n                \n                # Method 4: 31-based alternative\n                if not success:\n                    try:\n                        tracks_knob.setValueAt(x, frame, track_idx * 31 + 0)\n                        tracks_knob.setValueAt(y, frame, track_idx * 31 + 1)\n                        success = True\n                    except:\n                        pass\n                \n                if not success:\n                    print(f\"Warning: Could not set track data for track \{track_idx\} at frame \{frame\}\")\n\n    print(f\"Successfully created Tracker4 node with \{len(filtered_tracks)\} tracks\")\n    return tracker_node\n\ndef AddTracksToTracker4_WithFrameDict(camera_tracker_node, start_frame, end_frame, max_tracks=50, longest_only=True):\n    \"\"\"\n    Alternative version that uses the frame dictionary for even faster lookups\n    when you need to process specific frame ranges efficiently\n    \"\"\"\n    # Get optimized data structure\n    raw_tracks, frame_dict = GrabListData(camera_tracker_node)\n    \n    # Create new Tracker4 node\n    tracker_node = nuke.createNode(\"Tracker4\")\n    tracker_node.setName(\"CameraTracker_Converted_FrameDict\")\n\n    # Filter tracks based on length if requested\n    if longest_only:\n        tracks_with_length = \[(len(track), track) for track in raw_tracks]\n        tracks_with_length.sort(key=lambda x: x\[0], reverse=True)\n        filtered_tracks = \[track for length, track in tracks_with_length\[:max_tracks]]\n    else:\n        filtered_tracks = raw_tracks\[:max_tracks]\n\n    # Create a mapping of track indices for the filtered tracks\n    track_indices = \{\}\n    for i, track in enumerate(filtered_tracks):\n        # Find the original track index\n        for orig_idx, orig_track in enumerate(raw_tracks):\n            if track == orig_track:\n                track_indices\[orig_idx] = i\n                break\n\n    print(f\"Creating \{len(filtered_tracks)\} tracks using frame dictionary optimization\")\n\n    # Add tracks using frame dictionary for faster lookups\n    for track_idx in range(len(filtered_tracks)):\n        tracker_node.knob(\"add_track\").execute()\n    \n    tracks_knob = tracker_node.knob(\"tracks\")\n    \n    # Process frame by frame using the optimized dictionary\n    for frame in range(start_frame, end_frame + 1):\n        if frame in frame_dict:\n            frame_data = frame_dict\[frame]\n            for data_point in frame_data:\n                # data_point format: \[x, y, original_track_index, first_frame, last_frame]\n                x, y, orig_track_idx = float(data_point\[0]), float(data_point\[1]), data_point\[2]\n                \n                # Check if this track is in our filtered selection\n                if orig_track_idx in track_indices:\n                    new_track_idx = track_indices\[orig_track_idx]\n                    \n                    # Set the track data\n                    success = False\n                    try:\n                        tracks_knob.setValueAt(x, frame, new_track_idx, 0)\n                        tracks_knob.setValueAt(y, frame, new_track_idx, 1)\n                        success = True\n                    except:\n                        # Try alternative indexing methods if needed\n                        try:\n                            tracks_knob.setValueAt(x, frame, new_track_idx * 31 + 2)\n                            tracks_knob.setValueAt(y, frame, new_track_idx * 31 + 3)\n                            success = True\n                        except:\n                            pass\n                    \n                    if not success:\n                        print(f\"Warning: Could not set track data for track \{new_track_idx\} at frame \{frame\}\")\n\n    print(f\"Successfully created Tracker4 node with \{len(filtered_tracks)\} tracks using frame dictionary\")\n    return tracker_node\n\n# Usage Examples:\n# Method 1: Standard integration (recommended for most cases)\nnoop_node = nuke.thisNode()\n#print(noop_node.input(0).name())\nCameraTrackerName = str(noop_node.input(0).name())\ncamera_tracker = nuke.toNode(CameraTrackerName)\n#tracker_node = AddTracksToTracker4(camera_tracker, start_frame=1, end_frame=50, max_tracks=30, longest_only=True)\n\nstart = int(noop_node.knob(\"start_frame\").getValue())\nend = int(noop_node.knob(\"end_frame\").getValue())\nmaxtracks = int(noop_node.knob(\"max_tracks\").getValue())\n\n\n# Method 2(TOTO JE DOBRE): Frame dictionary optimization (for very large datasets or specific frame processing)\ntracker_node_optimized = AddTracksToTracker4_WithFrameDict(camera_tracker, start_frame=start, end_frame=end, max_tracks=maxtracks, longest_only=True)" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {26 _4 l "" +STARTLINE T "TrackAssist_PM v1.00 by Peter Mercell / 2025\nTool is heavily inspired by Mads Hagbarth"}
addUserKnob {26 _2 l "" +STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.petermercell.com\" target=\"_blank\" rel=\"noopener\">www.petermercell.com</a>\n"}
}
