set cut_paste_input [stack 0]
version 16.0 v3
push $cut_paste_input
NoOp {
name AxisConnect_PM
tile_color 0xffff00ff
selected true
xpos -124
ypos 849
hide_input true
addUserKnob {20 User l AxisConnect_PM}
addUserKnob {26 "" +STARTLINE}
addUserKnob {26 _99 l "" +STARTLINE T "For extraction Locators from CameraTracker select CameraTracker node and push Locators"}
addUserKnob {26 "" +STARTLINE}
addUserKnob {22 locators l Locators T "import nuke\nimport tempfile\nimport os\nimport re\n\ndef parse_fbx_ascii_translations(file_path):\n    locators = \{\}\n\n    with open(file_path, 'r') as f:\n        content = f.read()\n\n    pattern = re.compile(\n        r'Model: \\d+, \"Model::(locator\\d+)\", \"Null\" \{.*?Properties70:  \{(.*?)\}.*?\}', \n        re.DOTALL\n    )\n\n    for match in pattern.finditer(content):\n        locator_name = match.group(1)\n        properties_block = match.group(2)\n\n        trans_match = re.search(r'P: \"Lcl Translation\".*?,(-?\\d+\\.?\\d*),(-?\\d+\\.?\\d*),(-?\\d+\\.?\\d*)', properties_block)\n\n        if trans_match:\n            translate = \[float(trans_match.group(i)) for i in range(1, 4)]\n            locators\[locator_name] = translate\n\n    return locators\n\ndef create_axis_with_translation(name, translate):\n    axis = nuke.createNode(\"Axis\")\n    axis.setName(name)\n    axis\['translate'].setValue(translate)\n    axis.setInput(0, None)  # no connections\n    return axis\n\ndef create_all_axes_grid(locators, per_row=10, x_spacing=150, y_spacing=150):\n    selected = nuke.selectedNodes()\n    if selected:\n        start_x = selected\[-1].xpos()\n        start_y = selected\[-1].ypos() + 200  # start 200px below last selected node\n    else:\n        start_x = 0\n        start_y = 0\n\n    i = 0\n    for name, translate in sorted(locators.items()):\n        axis = create_axis_with_translation(name, translate)\n        \n        row = i // per_row\n        col = i % per_row\n        \n        x_pos = start_x + col * x_spacing\n        y_pos = start_y + row * y_spacing\n        \n        axis.setXpos(x_pos)\n        axis.setYpos(y_pos)\n        \n        i += 1\n\n\n# Get selected CameraTracker node\nselected_nodes = nuke.selectedNodes(\"CameraTracker\")\nif not selected_nodes:\n    nuke.message(\"Please select a CameraTracker node.\")\n    raise RuntimeError(\"No CameraTracker node selected\")\ntracker_node = selected_nodes\[0]\n\n# Create CameraTrackerPointCloud node\npoint_cloud = nuke.nodes.CameraTrackerPointCloud()\npoint_cloud.setInput(0, tracker_node)\n\n# Create WriteGeo node\nwrite_geo = nuke.nodes.WriteGeo()\nwrite_geo.setInput(0, point_cloud)\n\n# Set output FBX path\ntemp_dir = tempfile.gettempdir()\nfbx_path = os.path.join(temp_dir, \"pointcloud_ascii.fbx\")\nwrite_geo\['file'].setValue(fbx_path)\n\n# Correctly configure for FBX ASCII\nwrite_geo\['file_type'].setValue('fbx')  # Choose FBX\nwrite_geo\['asciiFileFormat'].setValue(True)  # Enable ASCII format\n\n# Execute single-frame export\nstart = end = nuke.root().firstFrame()\nnuke.execute(write_geo, start, end)\n\n# Optional cleanup\nnuke.delete(write_geo)\nnuke.delete(point_cloud)\n\n#print(f\"âœ… Point cloud exported as FBX ASCII to: \{fbx_path\}\")\n\nlocators = parse_fbx_ascii_translations(fbx_path)\ncreate_all_axes_grid(locators)\n\ntry:\n    os.remove(fbx_path)\nexcept Exception as e:\n    nuke.message(f\"Failed to delete temp file: \{e\}\")\n" +STARTLINE}
addUserKnob {26 "" +STARTLINE}
addUserKnob {2 file l AxisToRender}
file /Users/g/Downloads/AxisConnect_PM-main/AxisToRender.tcl
addUserKnob {26 ""}
addUserKnob {26 _1 l "" +STARTLINE T "1, Select all Axis / 2, Push:"}
addUserKnob {22 AxisConnect -STARTLINE T "import nuke\n\n# Get the current Nuke node (for obtaining file path from 'file' knob)\nref_node = nuke.thisNode()\n# Get the input parameters from the node\nfile = ref_node\['file'].getValue()\n\n# Path to the Group.tcl file\ngroup_file_path = file\n\n# Step 1: Create the AxisToRender nodes from the file and organize them\ndef create_axis_to_render_from_file(file):\n    # Paste the group node from the TCL file\n    nuke.nodePaste(file)\n    # Return the newly created node\n    return nuke.selectedNode()  # Returns the most recently pasted node\n\ndef organize_connect_and_scene():\n    # Step 1: Track the selected Axis nodes (including Axis4, Axis3, Axis2, Axis1, and Axis)\n    selected_nodes = \[node for node in nuke.selectedNodes() if node.Class() in \{\"Axis4\", \"Axis3\", \"Axis2\", \"Axis1\", \"Axis\"\}]\n\n    if not selected_nodes:\n        nuke.message(\"No Axis nodes selected. Please select Axis nodes to connect.\")\n        return \[]\n\n    # Step 2: Organize the Axis nodes horizontally\n    organize_nodes_horizontally(selected_nodes)\n\n    # List to store all newly created AxisToRender nodes\n    axis_to_render_nodes = \[]\n\n    # Step 3: Create and connect AxisToRender nodes below each Axis node\n    vertical_spacing = 100  # Distance between Axis and AxisToRender nodes\n    for axis in selected_nodes:\n        # Create AxisToRender node from the group file (use the global 'group_file_path')\n        group_node = create_axis_to_render_from_file(group_file_path)\n\n        # Position the AxisToRender node directly below the Axis node\n        group_node.setXYpos(axis.xpos(), axis.ypos() + vertical_spacing)\n\n        # Connect the Axis node to the AxisToRender node\n        group_node.setInput(0, axis)\n\n        # Add the new group node to the list\n        axis_to_render_nodes.append(group_node)\n\n    # Step 4: Connect all AxisToRender nodes to a Scene3D node\n    connect_to_scene3d(axis_to_render_nodes)\n\n    return axis_to_render_nodes  # Return the created AxisToRender nodes\n\ndef create_ctrl_node():\n    # Check if a node named 'CTRL' already exists\n    existing_ctrl_nodes = \[node for node in nuke.allNodes() if node\['name'].value() == 'CTRL']\n    \n    # Create a NoOp node and set a unique name\n    ctrl_node_name = 'CTRL'\n    if existing_ctrl_nodes:\n        # If a node named 'CTRL' exists, find the next available name (e.g., CTRL1, CTRL2, etc.)\n        i = 1\n        while any(node\['name'].value() == f'CTRL\{i\}' for node in nuke.allNodes()):\n            i += 1\n        ctrl_node_name = f'CTRL\{i\}'\n    \n    # Create the NoOp node with the determined name\n    ctrl_node = nuke.createNode('NoOp')\n    ctrl_node\['name'].setValue(ctrl_node_name)\n    \n    # Add a floating point slider (Double_Knob) inside the NoOp node with the name 'size'\n    size_knob = nuke.Double_Knob('size', 'size')\n    ctrl_node.addKnob(size_knob)\n    \n    # Set the min and max values of the slider\n    size_knob.setRange(1, 5)\n    \n    # Optionally, you can set a default value for the slider\n    size_knob.setValue(5)  # Default value for the slider\n    \n    # Set the color of the node to yellow (0xFFFF00FF)\n    ctrl_node\['tile_color'].setValue(0xFFFF00FF)\n    \n    return ctrl_node\n\ndef set_uniform_scale_expression(axis_to_render_nodes):\n    # Find the 'CTRL' node (or the most recent one created)\n    ctrl_node = None\n    for node in nuke.allNodes():\n        if node\['name'].value().startswith('CTRL'):\n            ctrl_node = node\n            break  # We found the first CTRL node, no need to continue\n\n    if ctrl_node:\n        # Set the expression for the 'uniform_scale' knob to reference the 'size' knob of the CTRL node\n        for axis_to_render_node in axis_to_render_nodes:\n            if 'uniform_scale' in axis_to_render_node.knobs():\n                axis_to_render_node\['uniform_scale'].setExpression(f\"\{ctrl_node.name()\}.size\")\n            else:\n                print(f\"uniform_scale knob not found in \{axis_to_render_node.name()\}\")\n    else:\n        print(\"CTRL node not found.\")\n\n# Function to organize nodes horizontally\ndef organize_nodes_horizontally(nodes):\n    # Define horizontal spacing\n    spacing = 150\n\n    # Sort nodes by their x-position to maintain relative order\n    nodes.sort(key=lambda node: node.xpos())\n\n    # Start organizing nodes horizontally\n    x_position = nodes\[0].xpos()  # Start at the x-position of the first node\n    y_position = nodes\[0].ypos()  # Keep the y-position consistent\n\n    for node in nodes:\n        node.setXYpos(int(x_position), int(y_position))\n        x_position += spacing  # Move to the right by the spacing value\n\n# Function to connect all AxisToRender nodes to a Scene3D node\ndef connect_to_scene3d(axis_to_render_nodes):\n    # Create a unique Scene3D node\n    scene_node_name = \"Scene1\"\n    i = 1\n    while any(node.Class() == \"Scene\" and node\['name'].value() == scene_node_name for node in nuke.allNodes()):\n        i += 1\n        scene_node_name = f\"Scene\{i\}\"\n\n    scene_node = nuke.createNode(\"Scene\")\n    scene_node\['name'].setValue(scene_node_name)\n\n    # Position the Scene3D node below the AxisToRender nodes\n    if axis_to_render_nodes:\n        first_axis = axis_to_render_nodes\[0]\n        scene_node.setXYpos(first_axis.xpos(), first_axis.ypos() + 200)\n\n    # Connect each AxisToRender node to the Scene3D node\n    for i, axis_to_render in enumerate(axis_to_render_nodes):\n        scene_node.setInput(i, axis_to_render)\n\n# Main function to execute the entire workflow\ndef main():\n    # Step 1: Create and organize AxisToRender nodes\n    axis_to_render_nodes = organize_connect_and_scene()\n\n    # Step 2: Only create the CTRL node if Axis nodes were selected\n    if axis_to_render_nodes:  # Check if any Axis nodes were selected\n        create_ctrl_node()\n\n    # Step 3: Set the uniform_scale expressions for the AxisToRender nodes\n    set_uniform_scale_expression(axis_to_render_nodes)\n\n# Run the combined function\nmain()\n"}
addUserKnob {26 ""}
addUserKnob {26 _0 l "" +STARTLINE T "AxisConnect_PM v1.03 by Peter Mercell / 2025\nAxisToRender by Gaetan Baldy"}
addUserKnob {26 _2 l "" +STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.petermercell.com\" target=\"_blank\" rel=\"noopener\">www.petermercell.com</a>"}
}