NoOp {
name TrackerReducer_PM
tile_color 0xffff00ff
selected true
xpos -779
ypos -791
hide_input true
addUserKnob {20 User l TrackerReducer_PM}
addUserKnob {1 trk l "Tracker Name"}
trk Tracker1
addUserKnob {3 KEEP_COUNT l "Keep Count" t "How many trackers you want to keep? "}
KEEP_COUNT 30
addUserKnob {26 "" +STARTLINE}
addUserKnob {22 test l Reduce T "\"\"\"\nreduce_tracker_nuke.py  v9\n--------------------------\nPaste into Nuke's Script Editor and run.\n\nApproach:\n  1. Parse the specified Tracker node → store chosen tracks in a list of dicts\n  2. Build a complete copy-paste .nk string (with version header)\n  3. nuke.nodePaste() to import as a real new node\n\"\"\"\n\nimport nuke\nimport re\nimport random\nimport tempfile\nimport os\n\n# ============================================================\n#  SETTINGS\n# ============================================================\n\n# Get the current Nuke node\nref_node = nuke.thisNode()\n\ntrkF = ref_node\['trk'].getValue()\nKEEP_COUNTF = int(ref_node\['KEEP_COUNT'].getValue())\n\nTRACKER_NODE = trkF\n\nKEEP_COUNT   = KEEP_COUNTF\n\nMETHOD       = \"spread\"  # \"spread\" | \"first\" | \"last\" | \"random\" | \"indices\"\n\nKEEP_INDICES = \[0, 3, 7] # only for METHOD = \"indices\"\n\nRANDOM_SEED  = 42        # None = truly random\n\n# ============================================================\n\n\n# ---- brace helpers ----\n\ndef find_brace(text, start=0):\n    idx = text.find('\{', start)\n    return idx if idx != -1 else -1\n\ndef match_brace(text, open_pos):\n    depth = 0\n    for i in range(open_pos, len(text)):\n        if text\[i] == '\{':\n            depth += 1\n        elif text\[i] == '\}':\n            depth -= 1\n            if depth == 0:\n                return i\n    return -1\n\ndef skip_block(text, pos):\n    s = find_brace(text, pos)\n    if s == -1: return -1\n    e = match_brace(text, s)\n    return e + 1 if e != -1 else -1\n\n\n# ---- parse ----\n\ndef parse_tracks(script):\n    \"\"\"\n    Returns (coldefs_str, list_of_track_block_strings)\n    toScript() gives: \{ header \} \{ coldefs \} \{ \{track\} \{track\} ... \}\n    \"\"\"\n    pos = 0\n    pos = skip_block(script, pos)           # skip \{ 1 N count \}\n\n    col_open  = find_brace(script, pos)\n    col_close = match_brace(script, col_open)\n    coldefs   = script\[col_open: col_close + 1]\n    pos = col_close + 1\n\n    data_open  = find_brace(script, pos)\n    data_close = match_brace(script, data_open)\n\n    tracks = \[]\n    search = data_open + 1\n    while search < data_close:\n        tb_open = find_brace(script, search)\n        if tb_open == -1 or tb_open >= data_close:\n            break\n        tb_close = match_brace(script, tb_open)\n        if tb_close == -1 or tb_close >= data_close:\n            break\n        block = script\[tb_open: tb_close + 1]\n        if 'curve' in block:\n            tracks.append(block)\n        search = tb_close + 1\n\n    return coldefs, tracks\n\n\ndef get_track_name(block):\n    m = re.search(r'\"(\[^\"]+)\"', block)\n    return m.group(1) if m else \"unknown\"\n\n\n# ---- selection ----\n\ndef select_indices(total, count, method):\n    if count >= total:\n        return list(range(total))\n    if method == \"first\":\n        return list(range(count))\n    elif method == \"last\":\n        return list(range(total - count, total))\n    elif method == \"random\":\n        if RANDOM_SEED is not None:\n            random.seed(RANDOM_SEED)\n        return sorted(random.sample(range(total), count))\n    elif method == \"spread\":\n        if count == 1:\n            return \[total // 2]\n        step = (total - 1) / (count - 1)\n        indices = sorted(set(round(i * step) for i in range(count)))\n        while len(indices) < count:\n            for c in range(total):\n                if c not in indices:\n                    indices.append(c); indices.sort(); break\n        return indices\[:count]\n    elif method == \"indices\":\n        bad = \[i for i in KEEP_INDICES if i < 0 or i >= total]\n        if bad:\n            raise IndexError(f\"Out of range (0-\{total-1\}): \{bad\}\")\n        return sorted(set(KEEP_INDICES))\n    raise ValueError(f\"Unknown method: \{method!r\}\")\n\n\n# ---- store chosen tracks in a dict ----\n\ndef parse_curve(curve_str):\n    \"\"\"Parse \{curve \[flags] xN v0 v1 ...\} -> \[(frame, value), ...]\"\"\"\n    inner = curve_str.strip().lstrip('\{').rstrip('\}').strip()\n    tokens = inner.split()\n    if not tokens or tokens\[0] != 'curve':\n        return \[]\n    tokens = tokens\[1:]\n    while tokens and re.match(r'^\[A-Za-z]\$', tokens\[0]):\n        tokens = tokens\[1:]\n    if not tokens:\n        return \[]\n    m = re.match(r'^x(-?\\d+)\$', tokens\[0])\n    if m:\n        frame = int(m.group(1))\n        tokens = tokens\[1:]\n    else:\n        frame = 1\n    result = \[]\n    for t in tokens:\n        try:\n            result.append((frame, float(t)))\n            frame += 1\n        except ValueError:\n            pass\n    return result\n\n\ndef tracks_to_dict(selected_blocks):\n    \"\"\"\n    Store chosen tracks as a list of dicts:\n      \{ 'name': str, 'raw_block': str \}\n    We keep the raw block string — that's all we need for the .nk rebuild.\n    Also extract parsed x/y for reference.\n    \"\"\"\n    result = \[]\n    for block in selected_blocks:\n        name = get_track_name(block)\n        # collect sub-blocks\n        subs = \[]\n        search = 1\n        end = len(block) - 1\n        while search < end:\n            ob = find_brace(block, search)\n            if ob == -1 or ob >= end: break\n            cb = match_brace(block, ob)\n            if cb == -1: break\n            subs.append(block\[ob:cb+1])\n            search = cb + 1\n        x_keys = parse_curve(subs\[1]) if len(subs) > 1 else \[]\n        y_keys = parse_curve(subs\[2]) if len(subs) > 2 else \[]\n        result.append(\{\n            'name':      name,\n            'raw_block': block,     # used directly in .nk rebuild\n            'x_keys':    x_keys,    # for reference / debug\n            'y_keys':    y_keys,\n        \})\n    return result\n\n\n# ---- build .nk and paste ----\n\ndef build_and_paste(source_node, coldefs, track_dict_list, new_name):\n    \"\"\"\n    Write a complete Tracker4 .nk node (with copy-paste header) to a\n    temp file and use nuke.nodePaste() to import it.\n    \"\"\"\n    n = len(track_dict_list)\n    # number of columns is 31 (from \{ 1 31 count \})\n    header = f'\{\{ 1 31 \{n\} \}\}'\n\n    data_rows = '\\n'.join(f' \{td\[\"raw_block\"]\} ' for td in track_dict_list)\n    tracks_value = (\n        header + ' \\n'\n        + coldefs + ' \\n'\n        + '\{ \\n' + data_rows + '\\n\} \\n'\n    )\n\n    xpos = source_node.xpos() + 100\n    ypos = source_node.ypos() + 100\n\n    # Full copy-paste .nk format (version header is required by nodePaste)\n    nk_text = (\n        \"set cut_paste_input \[stack 0]\\n\"\n        \"version 16.0 v6\\n\"\n        \"push \$cut_paste_input\\n\"\n        f\"Tracker4 \{\{\\n\"\n        f\" tracks \{\{ \{tracks_value\}\}\}\\n\"\n        f\" name \{new_name\}\\n\"\n        f\" xpos \{xpos\}\\n\"\n        f\" ypos \{ypos\}\\n\"\n        \"\}\\n\"\n    )\n\n    fd, tmp_path = tempfile.mkstemp(suffix='.nk', prefix='reduce_tracker_')\n    try:\n        with os.fdopen(fd, 'w') as f:\n            f.write(nk_text)\n\n        for node in nuke.allNodes():\n            node.setSelected(False)\n\n        nuke.nodePaste(tmp_path)\n\n    finally:\n        try:\n            os.unlink(tmp_path)\n        except Exception:\n            pass\n\n    new_nodes = nuke.selectedNodes()\n    if new_nodes:\n        return new_nodes\[0]\n    return None\n\n\n# ---- main ----\n\ndef reduce_tracker():\n    source = nuke.toNode(TRACKER_NODE)\n    if source is None:\n        nuke.message(f\"Node '\{TRACKER_NODE\}' not found in script.\")\n        return\n    if \"Tracker\" not in source.Class():\n        nuke.message(f\"'\{source.name()\}' is not a Tracker node.\")\n        return\n\n    script = source.knob(\"tracks\").toScript()\n    coldefs, all_blocks = parse_tracks(script)\n    total = len(all_blocks)\n\n    print(f\"\\n  Source : \{source.name()\}  (\{source.Class()\})\")\n    print(f\"  Tracks : \{total\} found\\n\")\n\n    if total == 0:\n        nuke.message(\"No tracks found.\")\n        return\n\n    if METHOD == \"indices\":\n        keep = select_indices(total, len(KEEP_INDICES), \"indices\")\n    else:\n        keep = select_indices(total, KEEP_COUNT, METHOD)\n\n    if len(keep) >= total:\n        nuke.message(f\"Only \{total\} tracks — nothing to reduce.\")\n        return\n\n    # Store the chosen tracks in a list of dicts\n    chosen_blocks = \[all_blocks\[i] for i in keep]\n    track_dicts = tracks_to_dict(chosen_blocks)\n\n    print(f\"  Keeping \{len(track_dicts)\} tracks (method: \{METHOD\}):\")\n    for i, td in enumerate(track_dicts):\n        print(f\"    \[\{i:3d\}]  '\{td\['name']\}'  (\{len(td\['x_keys'])\} frames)\")\n\n    new_name = source.name() + \"_reduced\"\n    new_node = build_and_paste(source, coldefs, track_dicts, new_name)\n\n    if new_node is None:\n        nuke.message(\"Could not find pasted node. Check Script Editor output.\")\n        return\n\n    print(f\"\\n  Done! New node: '\{new_node.name()\}' — \{len(track_dicts)\} of \{total\} tracks kept.\\n\")\n\n\nreduce_tracker()" +STARTLINE}
addUserKnob {26 "" +STARTLINE}
addUserKnob {26 _3 l "" +STARTLINE T "TrackerReducer_PM v1.00 by Peter Mercell / 2026"}
addUserKnob {26 _2 l "" +STARTLINE T "<a style=\"color: #999999;\"><a style=\"color: #999999;\" href=\"http://www.petermercell.com\" target=\"_blank\" rel=\"noopener\">www.petermercell.com</a>"}
}
